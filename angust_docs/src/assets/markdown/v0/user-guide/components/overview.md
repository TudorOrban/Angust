
&nbsp;

# Components

Components are self-contained pieces of UI that you can define and use throughout your Angust application. They not only allow you to isolate and reuse chunks of code, but they also hold state and event handlers that make possible the development of highly dynamic apps. This section aims to cover the main features provided by Components.

&nbsp;

## Basics

A Component consists of a **Rust module** and a corresponding **HTML Template** . We will explore these in detail in the next subsections, but for now take a look at the following example:

```rust
// some_component.rs
use std::collections::HashMap;

use angust::rendering::elements::component::{
    component::Component, 
    component_factory_registry::ComponentFactory, 
    state::reflectivity::NoState, 
};


pub struct SomeComponent;

impl SomeComponent {
    pub fn register(registry: &mut HashMap<String, ComponentFactory>) {
        registry.insert("some-component".to_string(), Box::new(move || {
            
            let component = Component::new(
                "some-component".to_string(),
                "src/app/some_component.html".to_string(),
                NoState
            );

            Box::new(component)
        }));
    }
} 
```

```html
<!-- some_component.html -->
<div>
    some-component works!
</div>
```

If you have worked in Angular before, this code may look familiar to you. We have a struct `SomeComponent` that specifies:

- the **name** of the component; you will use this name to include the component in other HTML templates
- the **path** to the corresponding HTML template; used by Angust to load the template at runtime
- the **state** of the component; we will explain this in the next section, for now it's a placeholder `NoState`

However, due to Rust's limitations, the registration process is notably less clean than Angular's Component Annotations. Instead, we have to manually add to a global registry a *Component Factory*, i.e. a method through which Angust can instantiate your components at runtime. 

Moreover, we have to call the `register` function at some point in the initialization. This is done by convention in the `component_registration.rs` module at the root of `src`:

```rust
use angust::rendering::elements::component::component_factory_registry::initialize_component_registry;

use crate::app::some_component::SomeComponent;

pub fn register_components() {
    let mut registry = HashMap::new();

    SomeComponent::register(&mut registry);

    initialize_component_registry(registry);
}
```

This `register_components` is then called in `main.rs`, as you can see in the project generated by the Angust CLI tool.

We will see later that Component States and Component Functions similarly require more verbosity in declaration.

&nbsp;

## Generate Components automatically

You don't need to write this boilerplate code every time you need a new component. You can just run:
```
angust_cli generate component src/app/Some
```
and the CLI tool will set up everything for you. Just ensure to specify the path starting with `src/app`, and to provide the component name without the `Component` part, which gets added automatically.

&nbsp;

## Next Step
Now that you have an idea of how components are defined in Angust, you can jump into the [Component State](https://tudorban.github.io/Angust/v0/user-guide/components/component-state) section.

&nbsp;